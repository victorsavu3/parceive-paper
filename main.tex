\documentclass[conference]{IEEEtran}

\ifCLASSOPTIONcompsoc
  \usepackage[nocompress]{cite}
\else
  \usepackage{cite}
\fi

\usepackage[pdftex]{graphicx}
\graphicspath{{../img/}}

\begin{document}

\title{Parceive\\The Paper}

\author{A. Wilhelm,
		V. Savu
        and~E. Amadasun}% <-this % stops a space

\IEEEtitleabstractindextext{%
\begin{abstract}
The abstract goes here.
\end{abstract}

\begin{IEEEkeywords}
Computer Society, IEEE, IEEEtran, journal, \LaTeX, paper, template.
\end{IEEEkeywords}}

\maketitle


\IEEEdisplaynontitleabstractindextext
\IEEEpeerreviewmaketitle

\section{Introduction}
\label{sec:introduction}

\section{Parallelization}
\label{sec:parallelization}

\section{Parceive}
\label{sec:parceive}

\subsection{System Architecture}
\label{sec:system_architecture}

\subsection{Data Model}
\label{sec:data_model}

\subsection{Data Extraction}
\label{sec:data_extraction}

\section{Views}
\label{sec:views}

\subsection{Profiling View}
\label{sec:profiling_view}

\subsection{CCT View}
\label{cct_view}

\section{Case Studies}
\label{sec:case_studies}

\subsection{CppCheck}
\label{sec:cppcheck}

\subsection{TensorFlow}
\label{sec:tensorflow}

\section{Discussion}
\label{sec:discussion}

\section{Related Work}
\label{sec:related_work}

\subsection{Software Comprehension}
\label{sec:software_comprehension}

\subsection{Parallelization}
\label{sec:related_work_parallelization}

\section{Conclusion}
\label{sec:conclusion}

\section{Framework}

\subsection{Database processing}
\label{dataprocessing}

The database layout and settings used by Parceive are highly optimized for writing. All the trace data required by the visualization can be obtained by using queries, but most of the operations will take a disproportionate amount of time to complete.

The first problem with databases optimized for writing is the lack of indexes. Thus, the most important step of the database processing is the creation of multiple indexes to improve record lookup. All primary and foreign keys are indexed and some composite indexes are created to speed up queries that perform poorly.

The data requested by visualizations requires joins across three or more tables and did not perform well. By adding additional fields and creating intermediary tables, it is possible to avoid joins for most queries executed by the visualizations. Since no additional data will be added to the database, creating redundancy generates no runtime overhead and does not increase the complexity.

Trace databases are not created by inserting entries in order and become very fragmented. Executing \texttt{VACUUM}, a SQL statement, after all processing is completed eliminates this problem. The increased locality of data reduces the execution time of most queries and has a considerable effect on ones that require a full table scan. \texttt{VACUUM} is also able to reduce the size of the processed database.

\subsubsection*{Performance}

The time required by the database processing is negligible because loading most visualizations without the optimizations would waste more than the processing itself. The only downside is the increased size of the database.

\subsection{NodeJS Server}

Loading large trace databases into current browsers may exceed their memory restrictions. To solve this problem a simple NodeJS Server was developed hat reads data from a processed database on demand.

The server exposes a REST \cite{rest} API for the retrieval of data. For security reasons all SQL queries are integrated in this server without support for arbitrary queries. The implementation makes use of multiple parallel reads to the same database to reduce the latency and throughput when large amounts of data is requested by the visualizations.

\subsection{ORM}

Views developed within the Parceive architecture can employ an Object Relational Mapper to simplify development and improve performance. The ORM makes it possible to access entities and to easily navigate the relationships between them. The API is implemented using promises \cite{promises} simplifying the asynchronous and parallel behavior.

The greatest benefit of using this ORM in views is the possibility of applying optimizations to the data loading. The most important ones are caching and pipelining.

Caching allows the ORM to avoid loading data that has been accessed before. Each time an entity is retrieved from the server it is saved and reused for subsequent requests. This optimization allows the views to focus on data presentation instead of efficient data retrieval.

Pipelining combines multiple queries to the same REST API call into a single one. When requesting a large number of entities this approach improves performance despite the limit on the number of parallel requests in browsers. This optimization is designed to greatly increase throughput at the cost of an increased response time.

\subsection{Visualization Framework}

As part of the Parceive UI a visualization framework has been developed to handle the layout and communication of multiple visualizations. The implementation is based on AngularJS and it completely separates visualizations into separate applications. The main features of the framework are as follows:

\subsubsection{State management}

The visualization framework implements a centralized and persistent state storage for visualizations. With the use of this feature it is possible to retain the state of views across page loads.

Currently the view layout and the marked entities are stored as part of the state automatically. In addition to this each visualization can save tailored information at any time and retrieve it when rendering. Local storage is used to house all the state information making it persistent.

\subsubsection{Communication}

Views allow the user to navigate the callgraph in different ways. Communication makes it possible to follow a chain of investigation along multiple visualizations. Currently there are three ways to communicate intent:

\textbf{Focus} brings entities to the attention of the user

\textbf{Mark} allows the creation of selections that are visible between visualizations

\textbf{Spot} replaces all the entities in a visualization with a new set

\textbf{Hover} brings entities to the attention of the user using opacity

\section{Visualizations}

\subsection{Source View}

The source view shows source code in files that wew used to build the instrumented application.

The usefulness of this view becomes apparent when it is communicating with the other views presented in this paper. The simplest interaction is focusing which allows the source view to pinpoint the definition of functions an loops making it easy to follow the execution of a program trough the source code.

Hovering is able to provide additional information about entities. For calls it can indicate where the call originated and for memory references where they were allocated and accessed.

\subsection{Calling Context Tree (CCT) View}

The CCT View is a visualization that allows users to easily comprehend the dynamic behavior of an application. It can display and navigate calls, loops and references.

The first node present when the view is created is the call to \texttt{main}. The user can then expand it like any other call to show its children. When a function is called multiple times the calls are grouped into a call group to reduce the number of nodes displayed. Call groups can be decomposed into their calls if needed.

Loops can be visually identified by icons on nodes. When a loop icon is present on the right side of a node then that node contains one or more loops. These loops can be added and navigated using the visualization. A icon on the left side indicates that the call has been made from inside a loop. Navigating loop executions and loop iterations is similar to calls and allows the user to see information at any granularity he desires.

Call groups, calls, loop executions and loop iterations are sorted by their start time and positioned using the D3 tree layout.

References accessed by parts of the application can be displayed by using the context menu. They are difficult to integrate as part of a graph layout and are positioned using a force simulation around the rest of the tree.

This view has some additional features that aim to help a developer parallelize code:

\begin{itemize}
	\item Profiling information is present as the node color
	\item References shared between nodes can be easily identified
	\item It is easy to expand the references accessed during the inclusive execution of a call or callgroup
	\item A specialized query that only display the shared references between nodes
\end{itemize}

\appendices
\section{Proof of the First Zonklar Equation}
Appendix one text goes here.

% you can choose not to have a title for an appendix
% if you want by leaving the argument blank
\section{}
Appendix two text goes here.

% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
\ifCLASSOPTIONcaptionsoff
  \newpage
\fi

\end{document}


