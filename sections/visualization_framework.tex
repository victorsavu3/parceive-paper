\section{Visualization Framework}

In this section, we 

\subsection{Database processing}
\label{dataprocessing}

The database layout and settings used by Parceive are highly optimized for fast
writing. All the information required by the visualization can be obtained by
using queries, but most of the operations will take a disproportionate amount
of time to complete. The first problem with the database is that Parceive
avoids the creation of indexes to improve write performance. Thus, the most
important step of the database processing is the creation of multiple indexes
to improve record lookup. All primary and foreign keys are indexed and some
composite indexes are created to speed up specific queries.

Since no additional data will be added to the database, creating redundancy
generates no overhead and does not increase the complexity. By adding
additional fields and creating intermediary tables, it is possible to avoid
joins for most queries executed by the visualizations. 

Executing \texttt{VACUUM} after all processing is done also improves
performance by reducing the fragmentation of data stored inside tables. The
increased locality of data reduces the execution time of most queries and has a
considerable effect on ones that require a full table scan. \texttt{VACUUM} is
also able to reduce the size of the processed
database.

\subsubsection*{Performance}

Figure \ref{parceive:procperformance} shows the time and size overhead of
processing databases generated by Parceive. The time required by this operation
is negligible because loading most visualizations without the optimizations
would waste more than the processing itself. The executed queries are also
heavily optimized making \texttt{VACUUM} and the creation of indexes the most
time consuming operations. The size increase is unfortunately unavoidable.

\begin{figure}
	\centering
	\begin{tabular}{l l l l}
		Database & Size & Processed Size & Time taken \\
		emsim\_par & 3905536 & 14560256 & 8.77 s
	\end{tabular}
	\caption{Database processing performance}
	\label{parceive:procperformance}
\end{figure}

\subsection{NodeJS Server}
Loading the entire database into the browser is not possible when the trace is
too large. To solve this problem a simple NodeJS Server was developed to read
data from a processed database on demand.

The server exposes a very simple REST \cite{rest} API that only allows the
retrieval of data. For security reasons all SQL queries are contained in this
server and arbitrary queries are not supported. The implementation makes use
of multiple parallel reads to the same database to reduce the latency and
throughput when large amounts of data is requested by the visualizations.

\subsection{ORM}

Visualizations developed within the Parceive architecture can employ a Object
Relational Mapper to simplify development and improve performance. The ORM
makes it possible to access entities and to easily navigate the relationships
between them. The API is implemented using promises \cite{promises} simplifying
the asynchronous and parallel behavior. 

The greatest benefit to using this ORM in visualizations is the possibility of
applying optimizations to the data loading. The most important ones are caching
and pipelining. Caching allows the ORM to avoid loading data that has been
accessed before. Each time an entity is retrieved from the server it is saved
and reused for subsequent requests. This optimization allows visualizations to
focus more on data presentation instead of efficient data retrieval.

Pipelining combines multiple queries to the same endpoint into a single one.
When requesting a large number of entities it can improve performance despite
the limit on the number of parallel requests in browsers. This optimization is
designed to greatly increase throughput at the cost of a response time
increased by 10 milliseconds.

\subsection{Visualization Framework}
The visualization component consists of a visualization framework and several
views that are based on the framework. Each view simplifies and highlight
specific aspects of the traced software. Examples are a performance view to
detect hotspots, or a function view that depicts memory dependencies between
functions. The biggest challenge when dealing with runtime traces is the
potentially
overwhelming amount of data. Often such traces lead to unmanageable
visualizations with unpractical delays. We address this problem by providing
three key services to each view. The first service allows on-demand loading of
arbitrary trace data and its caching for reuse across views. Most importantly,
this service enables users to navigate and explore their software. The second
service is the abstraction of fine-grained trace information to high-level
entities, e.g., from single function invocations to call-groups, or from
objects to classes. Such abstractions allow to comprehend software by using
scalable top-down approaches. The third service comprises a communication
infrastructure for sharing arbitrary state across multiple views. This service
can be used to spot and restrict the current range of view to crucial points in
the trace. Equipped with all these services, the visualization component allows
scalable views for software analysis.


As part of the Parceive UI a visualization framework has been developed to
handle the layout and communication of multiple visualizations. The
implementation is based on AngularJS and it completely separates visualizations
into separate applications.

\subsubsection{State management}

The visualization framework implements a centralized and persistent state
storage for visualizations. With the use of this feature it is possible to
retain the state of views across page loads.

Currently the view layout and the marked nodes are stored as part of the state
automatically. In addition to this each visualization can save tailored
information at any time and retrieve it when rendering. Local storage is used
to house all the state information making it persistent.

\subsubsection{Communication}

Visualizations perform different tasks and allow the user to navigate the
callgraph in different ways. Communication makes it possible to follow a chain
of investigation along multiple visualizations. Currently there are three ways
to communicate intent:

\begin{itemize}
	\item[Focus] brings entities to the attention of the user
	\item[Mark] allows the creation of selections that are visible between
visualizations
	\item[Spot] replaces all the entities in a visualization with a new set
	\item[Hover] brings entities to the attention of the user using opacity
\end{itemize}